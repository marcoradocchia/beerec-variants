use darling::ast::Data;
use darling::{FromDeriveInput, FromVariant};
use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use syn::{DeriveInput, Error, Ident};

#[derive(FromVariant)]
#[darling(attributes(variants))]
struct TargetVariant {
    ident: Ident,
    #[darling(default)]
    rename: Option<String>,
    #[darling(default)]
    rename_abbr: Option<String>,
    #[darling(default)]
    skip: bool,
}

impl TargetVariant {
    fn ident(&self) -> Option<&Ident> {
        (!self.skip).then_some(&self.ident)
    }

    #[rustfmt::skip]
    fn as_str_match_branch(&self) -> TokenStream2 {
        let Self { ident, rename, .. } = self;

        let name = rename.clone().unwrap_or(ident.to_string());
        quote::quote! { Self::#ident => #name }
    }

    #[rustfmt::skip]
    fn as_abbr_str_match_branch(&self) -> TokenStream2 {
        const ABBR_STR_LEN: usize = 3;

        let Self { ident, rename, rename_abbr, .. } = self;

        let name_abbr = rename_abbr.clone().unwrap_or_else(|| {
            let mut name = rename.clone().unwrap_or(ident.to_string());
            if name.len() > ABBR_STR_LEN { name.truncate(ABBR_STR_LEN); }
            name
        });

        quote::quote! { Self::#ident => #name_abbr }
    }
}

#[derive(FromDeriveInput)]
#[darling(supports(enum_unit))]
struct TargetEnum {
    ident: Ident,
    data: Data<TargetVariant, ()>,
}

#[rustfmt::skip]
fn derive_enum_variants_impl(input: &DeriveInput) -> syn::Result<TokenStream2> {
    let TargetEnum { ident, data } = TargetEnum::from_derive_input(input)?;

    let variants = match data {
        Data::Enum(ref variants) => variants,
        Data::Struct(_) => unreachable!(),
    };

    let variant_count = variants.iter().filter(|variant| !variant.skip).count();
    let variant_idents = variants.iter().filter_map(TargetVariant::ident);
    let variant_as_str_match_branches = variants.iter().map(TargetVariant::as_str_match_branch);
    let variant_as_abbr_str_match_branches = variants.iter().map(TargetVariant::as_abbr_str_match_branch);

    let as_str_doc = format!(r#"Returns a string representation of the [`{ident}`] variant.

# Notes

String representation of enum variants generated by the [`Variants`] macro can
be overridden by marking the enum variant as `#[variants(rename = "<override>")]`."#);

    let as_abbr_str_doc = format!(r#"Returns an abbreviated string representation of the [`{ident}`] variant.

# Notes

The abbreviated string representation of enum variants generated
by the [`Variants`] macro is determined by the following decreasing
priority list.
- **Abbreviated string representation override**: if the variant is marked
  as `#[variants(rename_abbr = "<override>")]`, returns the provided
  `<override>` value.
- **String representation override**: if the variant is marked as
  `#[variants(rename = "<override>")]` but has no `rename_abbr`, returns
  a string slice of the first three characters of the `<override>` value.
- **Default behavior**: if neither of `rename` or `rename_abbr` is specified,
  returns a string slice of the first three character of the variant's
  identifier."#);

    let iter_variants_as_str_doc = format!(r"Iterates over string representation of enum variants.
See `{ident}::as_str` for further details about yielded values.

# Notes

Enum variants marked as `#[variants(skip)]` are excluded from iteration.");

    let iter_variants_as_abbr_str_doc = format!(r"Iterates over abbreviated string representation of enum variants.
See `{ident}::as_abbr_str` for further details about yielded values.

# Notes

Enum variants marked as `#[variants(skip)]` are excluded from iteration.");

    Ok(quote::quote! {        
        impl ::std::clone::Clone for #ident {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl ::std::marker::Copy for #ident {}

        #[automatically_derived]
        impl #ident {
            /// The array of iterable (i.e. non-skipped) enum variants.
            const ITERABLE_VARIANTS: [Self; #variant_count] = [
                #(Self::#variant_idents,)*
            ];

            #[inline]
            #[must_use]
            #[doc = #as_str_doc]
            pub fn as_str(self) -> &'static str {
                match self {
                    #(#variant_as_str_match_branches,)*
                }
            }

            #[inline]
            #[must_use]
            #[doc = #as_abbr_str_doc]
            pub fn as_abbr_str(self) -> &'static str {
                match self {
                    #(#variant_as_abbr_str_match_branches,)*
                }
            }

            /// Iterates over enum variants.
            ///
            /// # Notes
            ///
            /// Enum variants marked as `#[variants(skip)]` are ignored.
            pub fn iter_variants() -> impl ::std::iter::Iterator<Item = Self> {
                Self::ITERABLE_VARIANTS.into_iter()
            }

            #[doc = #iter_variants_as_str_doc]
            pub fn iter_variants_as_str() -> impl ::std::iter::Iterator<Item = &'static str> {
                Self::iter_variants().map(Self::as_str)
            }

            #[doc = #iter_variants_as_abbr_str_doc]
            pub fn iter_variants_as_abbr_str() -> impl ::std::iter::Iterator<Item = &'static str> {
                Self::iter_variants().map(Self::as_abbr_str)
            }
        }
    })
}

/// Procedural derive macro to generate boilerplate on unit variants `enum` types.
///
/// The [`Variants`] macro generates the following methods:
/// - `as_str` returning a string representation of the `enum` variant;
/// - `as_abbr_str` returning an abbreviated string representation of the `enum` variant;
/// - `iter_variants` returning an iterator over owned `enum` variants;
/// - `iter_variants_as_str` returning an iterator over string representations of the `enum` variants;
/// - `iter_variants_as_abbr_str` returning an iterator over abbreviated string representations of the `enum` variants.
///
/// # Variant attributes
///
/// The [`Variants`] macro exposes the following variant attributes:
/// - `skip` to exclude the marked variant from iteration;
/// - `rename` to assign a custom string representation to the marked variant;
/// - `rename_abbr` to assign a custom abbreviated string representation to the marked variant.
///
/// # Errors
///
/// The macro will produce a compile error if:
/// - derived on `struct` types;
/// - derived on `union` types;
/// - derived on `enum` types with any number of named field variants;
/// - derived on `enum` types with any number of unnamed field (i.e. tuple) variants;
/// - derived on `enum` types with any number of newtype variants;
/// - the `rename` variant attribute is passed any other value type than a string literal;
/// - the `rename_abbr` variant attribute is passed any other value type than a string literal.
///
/// # Notes
/// 
/// Deriving [`Variants`] on type automatically implements [`Clone`] and [`Copy`] for such type.
/// This means that deriving [`Clone`] or [`Copy`] on a type that also derives [`Variants`]
/// will result in a compilation error for conflicting implementations.
///
/// [`Clone`]: https://doc.rust-lang.org/std/clone/trait.Clone.html
/// [`Copy`]: https://doc.rust-lang.org/std/marker/trait.Copy.html
///
/// # Examples
///
/// ```rust
/// use beerec_variants::Variants;
/// 
/// #[derive(Variants, PartialEq, Eq)]
/// enum Weekday {
///     #[variants(skip)]
///     Monday,
///     #[variants(rename = "DayAfterMonday", rename_abbr = "tue")]
///     Tuesday,
///     #[variants(rename_abbr = "wed")]
///     Wednesday,
///     Thursday,
///     Friday,
///     Saturday,
///     Sunday,
/// }
///
/// # fn main() {
/// assert_eq!(6, Weekday::iter_variants().count());
///
/// let mut weekdays = Weekday::iter_variants();
/// assert_eq!(Some(Weekday::Tuesday), weekdays.next());
/// assert_eq!(Some(Weekday::Wednesday), weekdays.next());
/// assert_eq!(Some(Weekday::Thursday), weekdays.next());
/// assert_eq!(Some(Weekday::Friday), weekdays.next());
/// assert_eq!(Some(Weekday::Saturday), weekdays.next());
/// assert_eq!(Some(Weekday::Sunday), weekdays.next());
/// assert_eq!(None, weekdays.next());
///
/// let mut weekdays_as_str = Weekday::iter_variants_as_str();
/// assert_eq!(Some("DayAfterMonday"), weekdays.next());
/// assert_eq!(Some("Wednesday"), weekdays.next());
/// assert_eq!(Some("Thursday"), weekdays.next());
/// assert_eq!(Some("Friday"), weekdays.next());
/// assert_eq!(Some("Saturday"), weekdays.next());
/// assert_eq!(Some("Sunday"), weekdays.next());
/// assert_eq!(None, weekdays.next());
///
/// let mut weekdays_as_abbr_str = Weekday::iter_variants_as_abbr_str();
/// assert_eq!(Some("tue"), weekdays.next());
/// assert_eq!(Some("wed"), weekdays.next());
/// assert_eq!(Some("Thu"), weekdays.next());
/// assert_eq!(Some("Fri"), weekdays.next());
/// assert_eq!(Some("Sat"), weekdays.next());
/// assert_eq!(Some("Sun"), weekdays.next());
/// assert_eq!(None, weekdays.next());
/// # }
/// ```
#[rustfmt::skip]
#[proc_macro_derive(Variants, attributes(variants))]
pub fn derive_enum_variants(input: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(input as DeriveInput);

    derive_enum_variants_impl(&input)
        .unwrap_or_else(Error::into_compile_error)
        .into()
}

#[cfg(test)]
mod test {
    #[test]
    fn expand() {
        macrotest::expand("tests/expand/*.rs");
    }

    #[test]
    fn error() {
        let test = trybuild::TestCases::new();
        test.compile_fail("tests/fail/*.rs");
    }
}
